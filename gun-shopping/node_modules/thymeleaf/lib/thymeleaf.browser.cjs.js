'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Common class for dialects.
 * 
 * @author Emanuel Rabina
 */
class Dialect {

  /**
   * Constructor, sets this dialect's name and prefix.
   * 
   * @param {String} name
   * @param {String} prefix
   */
  constructor(name, prefix) {

    this.name = name;
    this.prefix = prefix;
  }
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Common class for attribute processors.
 * 
 * @author Emanuel Rabina
 */
class AttributeProcessor {

	/**
  * Constructor, sets this processor's prefix and name.
  * 
  * @param {String} prefix
  * @param {String} name
  */
	constructor(prefix, name) {

		this.prefix = prefix;
		this.name = name;
	}

	/**
  * Returns the attribute that was matched on the element.
  * 
  * @param {Element} element
  * @return {String}
  *   The attribute that matched processing by this processor, or `null` if no
  *   match was found.
  */
	matches(element) {
		let prefix = this.prefix,
		    name = this.name;


		let attribute = `${prefix}:${name}`;
		if (!element.hasAttribute(attribute)) {
			attribute = `data-${prefix}-${name}`;
			if (!element.hasAttribute(attribute)) {
				return null;
			}
		}
		return attribute;
	}
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Flattens an arrays of arrays into a single array.
 * 
 * @param {Array} array
 * @return {Array} Flattened array.
 */
function flatten(array) {

  return array.reduce((accumulator, value) => {
    return accumulator.concat(Array.isArray(value) ? flatten(value) : value);
  }, []);
}

/**
 * Creates an array of numbers from the starting value (inclusive) to the end
 * (exclusive), with an optional step (the gap between values).
 * 
 * @param {Number} start
 *   The value to start at, the first item in the returned array.
 * @param {Number} end
 *   The value to end with, the last item in the returned array.
 * @param {Number} [step=1]
 *   The increment/gap between values, defaults to 1.
 * @return {Array} An array encompassing the given range.
 */


/**
 * Remove and return the first item from `array` that matches the predicate
 * function.
 * 
 * @param {Array} array
 * @param {Function} predicate
 *   Invoked with the array item.
 * @return {Object} The matching item, or `null` if no match was found.
 */
function remove(array, predicate) {

  return array.find((item, index) => {
    if (predicate(item)) {
      array.splice(index, 1);
      return item;
    }
  });
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Deep-merges all of the properties of the objects in `sources` with `target`,
 * modifying the target object and returning it.
 * 
 * @param {Object} target
 * @param {...Object} sources
 * @return {Object} The modified target object.
 */
function merge() {
  let target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  sources.forEach(source => {
    if (source) {
      Object.keys(source).forEach(key => {
        let targetValue = target[key];
        let sourceValue = source[key];
        target[key] = targetValue instanceof Object && sourceValue instanceof Object ? merge(targetValue, sourceValue) : sourceValue;
      });
    }
  });
  return target;
}

/**
 * Returns a value from an object via a path string that describes the nesting
 * of objects to get to the value.
 * 
 * eg:
 * 
 * ```
 * let object = {
 *   greeting: {
 *     message: 'Hello!'
 *   }
 * };
 * let pathToMessage = 'greeting.message';
 * ```
 * 
 * @param {Object} object
 * @param {String} path A dot-separated string of paths to get to the desired
 *   value within the object
 * @return {Object} The value at the given path within the object, or
 *   `undefined` if the path doesn't resolve within the object.
 */
function navigate(object, path) {

  return path.split('.').reduce((previousValue, pathToken) => {
    return previousValue && previousValue[pathToken];
  }, object);
}

var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();















var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};





















var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: This should really be done using a parser generator like PEG.js so that
//       we can discern between the various expression syntaxes and so execute
//       the right functions for handling them.  For now, only assumed
//       expressions are supported, with separate functions for each of those
//       best guesses.

/**
 * Parses and evaluates a Thymeleaf expression.
 * 
 * @param {String} expression
 * @param {Object} [context={}]
 * @return {String} The result of evaluating the expression.
 */
function processExpression(expression) {
	let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


	let result = /\$\{(.+)\}/.exec(expression);
	if (result) {
		var _result = slicedToArray(result, 2);

		let query = _result[1];

		return navigate(context, query) || '';
	}
	return expression;
}

/**
 * Parses and evaluates a Thymeleaf fragment expression.
 * 
 * @param {String} expression
 * @param {Object} [context={}]
 * @return {Object} Information about the fragment expression.
 */
function processFragmentExpression(expression) {
	let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


	let result = /~{ ?(.*?) ?:: ?(.*?)(\(.*\))? ?}/.exec(expression);
	if (result) {
		var _result2 = slicedToArray(result, 4);

		let templateName = _result2[1],
		    fragmentName = _result2[2],
		    parameters = _result2[3];

		let prefix = navigate(context, 'templateResolver.prefix');
		let suffix = navigate(context, 'templateResolver.suffix');
		return {
			templateName: (prefix || '') + templateName + (suffix || ''),
			fragmentName,
			parameters
		};
	}
	return null;
}

/**
 * Parses and evaluates a Thymeleaf iteration expression.
 * 
 * @param {String} expression
 * @param {Object} [context={}]
 * @return {Object} Information about the iteration expression.
 */
function processIterationExpression(expression) {
	let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


	let result = /(.+)\s*:\s*(\$\{.+\})/.exec(expression);
	if (result) {
		var _result3 = slicedToArray(result, 3);

		let localValueName = _result3[1],
		    navigationExpression = _result3[2];

		return {
			localValueName,
			iterable: processExpression(navigationExpression, context)
		};
	}
	return null;
}

/**
 * Parses and evaluates a Thymeleaf link expression.
 * 
 * @param {String} expression
 * @param {Object} [context={}]
 * @return {String} The result of evaluating the expression.
 */
function processLinkExpression(expression) {
	let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


	let result = /^@\{(.+?)(\(.+\))?\}$/.exec(expression);
	if (result) {
		var _result4 = slicedToArray(result, 3);

		let url = _result4[1],
		    params = _result4[2];

		if (params) {
			let paramsList = params.slice(1, -1).split(',').map(param => {
				var _param$split = param.split('='),
				    _param$split2 = slicedToArray(_param$split, 2);

				let lhs = _param$split2[0],
				    rhs = _param$split2[1];

				return [lhs, processExpression(rhs, context)];
			});

			// Fill out any placeholders in the URL from the parameters
			while (true) {
				// eslint-disable-line
				let urlTemplate = /(.*?)\{(.+?)\}(.*)/.exec(url);
				if (urlTemplate) {
					var _urlTemplate = slicedToArray(urlTemplate, 4);

					let head = _urlTemplate[1],
					    placeholder = _urlTemplate[2],
					    tail = _urlTemplate[3];

					let paramEntry = remove(paramsList, (_ref) => {
						var _ref2 = slicedToArray(_ref, 1);

						let lhs = _ref2[0];
						return lhs === placeholder;
					});
					if (paramEntry) {
						url = `${head}${paramEntry[1]}${tail}`;
					}
				} else {
					break;
				}
			}

			// Remaining parameters become search query parameters
			if (paramsList.length) {
				url += `?${paramsList.map((_ref3) => {
					var _ref4 = slicedToArray(_ref3, 2);

					let key = _ref4[0],
					    value = _ref4[1];
					return `${key}=${value}`;
				}).join('&')}`;
			}
		}
		return url;
	}
	return expression;
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Escapes special HTML characters in a string with their entity code
 * equivalents.
 * 
 * @param {String} string
 * @return {String}
 *   HTML escaped string, safe for use in HTML.
 */
function escapeHtml(string) {

  return typeof string !== 'string' ? string : string.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
}

/**
 * Returns the replacement of each placeholder in a template string with a
 * corresponding replacement value.
 * 
 * @param {String} template
 * @param {...String} values
 *   Argument list of values or a single array of values.
 * @return {String}
 *   Replaced template string.
 */

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:attr` attribute processor, modifies or sets
 * a target attribute to whatever its associated expression evaluates to.
 * 
 * @author Emanuel Rabina
 */
class StandardAttrAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `attr` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, StandardAttrAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:attr` or `data-th-attr` attribute
  * on it, picking out the target attributes and setting them to whatever their
  * expressions evaluate to.
  * 
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		if (/(.+=.+,)*.+=.+/.test(attributeValue)) {
			attributeValue.split(',').forEach(attribute => {
				let attributeParts = attribute.split('=');
				element.setAttribute(attributeParts[0], escapeHtml(processExpression(attributeParts[1], context)));
			});
		}
		/* istanbul ignore next */
		else if (process.env.NODE_ENV !== 'test') {
				console.warn(`Value to ${attribute}, ${attributeValue}, doesn't seem to contain an attribute assignment expression.  Ignoring.`);
			}
		element.removeAttribute(attribute);
	}
}
StandardAttrAttributeProcessor.NAME = 'attr';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:each` attribute processor, iterates over an
 * [iterable object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols),
 * executing a piece of template for every iteration.
 * 
 * @author Emanuel Rabina
 */
class StandardEachAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `each` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, StandardEachAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:each`/`data-th-each` attribute,
  * repeating the markup for every object in the iterable value.
  * 
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  * @return {Boolean} Whether or not the parent element needs to do a second
  *   pass as its children have been modified by this processor.
  */
	process(element, attribute, attributeValue, context) {

		element.removeAttribute(attribute);

		let iterationInfo = processIterationExpression(attributeValue, context);
		if (iterationInfo) {
			let localValueName = iterationInfo.localValueName,
			    iterable = iterationInfo.iterable;

			let templateNode = element.cloneNode(true);

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					let value = _step.value;

					let localClone = templateNode.cloneNode(true);
					let localVariable = {};
					localVariable[localValueName] = value;

					// TODO: Standardize this data attribute somewhere.  Shared const?
					// element.dataset not yet implemented in JSDOM (https://github.com/tmpvar/jsdom/issues/961),
					// so until then we're setting data- attributes the old-fashioned way.
					localClone.setAttribute('data-thymeleaf-local-variables', JSON.stringify(localVariable));

					element.parentElement.appendChild(localClone);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}
		element.parentElement.removeChild(element);

		return true;
	}
}
StandardEachAttributeProcessor.NAME = 'each';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:fragment` attribute processor, marks an
 * element as a template fragment that can be imported by other processors like
 * `th:insert`.
 * 
 * @author Emanuel Rabina
 */
class StandardFragmentAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `fragment` name and supplied
  * prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, StandardFragmentAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:fragment` or `data-th-fragment`
  * attribute on it.
  * 
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		element.removeAttribute(attribute);

		// TODO: Some off-context mechanism for encountered fragments?
		if (!context.fragments) {
			context.fragments = [];
		}
		context.fragments.push({
			name: attributeValue,
			element: element.cloneNode(true)
		});
	}
}
StandardFragmentAttributeProcessor.NAME = 'fragment';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:href` attribute processor, applies the
 * expression in the attribute value to the `href` attribute of the element
 * being processed.
 * 
 * @author Emanuel Rabina
 */
class StandardHrefAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `href` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, StandardHrefAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:href` or `data-th-href` attribute
  * on it, taking the possible link expression in the value and applying it to
  * the `href` attribute of the element.
  * 
  * @param {Element} element 
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		element.href = encodeURI(processLinkExpression(attributeValue, context));
		element.removeAttribute(attribute);
	}
}
StandardHrefAttributeProcessor.NAME = 'href';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* global "browser" */

/**
 * Removes all of an element's child nodes.
 * 
 * @param {Element} element
 */
function clearChildren(element) {

  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}

/**
 * Sets a Thymeleaf attribute and value on an existing element.  Used primarily
 * in tests.
 * 
 * @param {Element} element
 * @param {String} attribute
 * @param {String} value
 * @return {Element} The same element but with the attribute and value set on it.
 */


/**
 * Use either JSDOM or the browser's native DOM parsing to deserialize the HTML
 * string into a document fragment.
 * 
 * @param {String} htmlString
 * @return {DocumentFragment}
 */
function deserialize(htmlString) {

  return document.createRange().createContextualFragment(htmlString);
}

/**
 * Use either JSDOM or the browser's native DOM serialization to serialize a
 * document fragment into an HTML string.
 * 
 * @param {DocumentFragment} documentFragment
 * @return {String}
 */
function serialize(documentFragment) {

  return new XMLSerializer().serializeToString(documentFragment);
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:if` attribute processor, includes or
 * excludes the current element and its children from rendering, depending on
 * the evaluation of the expression in the attribute value.
 * 
 * @author Emanuel Rabina
 */
class StandardIfAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `if` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, StandardIfAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:if` or `data-th-if` attribute
  * on it, evaluating the expression for truthy/falsey, rendering/excluding the
  * element and its children based on the result.
  * 
  * @param {Element} element 
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		let expressionResult = processExpression(attributeValue, context);
		if (!expressionResult) {
			clearChildren(element);
			element.parentNode.removeChild(element);
		}
		element.removeAttribute(attribute);
	}
}
StandardIfAttributeProcessor.NAME = 'if';

/*
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A template resolution function that uses the CommonJS module system of the
 * `require` function with a path to the template.
 * 
 * @param {String} templatePath
 * @return {DocumentFragment} DOM of the template at the given path, or `null`
 *   if the path didn't resolve to a template.
 */
function resolveTemplate(templatePath) {

  // TODO: Return a promise of the template as template resolution is best done
  //       async (especially in the browser environment).

  // TODO: `templates` is a special path for recognizing templates, set up by a
  //       consuming app's webpack config, setting `resolve.alias` to the path
  //       to their templates.  This is a total hack and needs better dynamic
  //       support such as a Thymeleaf loader that can pick out other HTML to
  //       include.

  try {
    return deserialize(
    /* global "browser" */
    require(`templates/${templatePath}`));
  } catch (error) {
    return null;
  }
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * An element selector and shortcut for `(document/element).querySelector`.
 * 
 * @param {String} query
 * @param {Node} [scope=document]
 *   The scope to limit the search to for non-ID queries.  Defaults to `document`
 *   scope.
 * @return {Element} The matching element, or `null` if no match is found.
 */
function $(query) {
  let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;


  return scope.querySelector(query);
}

/**
 * An element list selector, returning an array of elements because
 * `NodeList`s are dumb.
 * 
 * @param {String} query
 * @param {Node} [scope=document]
 *   The scope to limit the search to for non-ID queries.  Defaults to `document`
 *   scope.
 * @return {Array} The list of matching elements.
 */

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:insert` attribute processor, inserts the
 * referenced template fragment as a child of the current element.
 * 
 * @author Emanuel Rabina
 */
class StandardInsertAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `insert` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, StandardInsertAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:insert`/`data-th-insert` attribute,
  * replacing the current element's children with the DOM in the referenced
  * fragment.
  * 
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  * @return {Boolean} Whether or not the parent element needs to do a second
  *   pass as its children have been modified by this processor.
  */
	process(element, attribute, attributeValue, context) {

		element.removeAttribute(attribute);
		clearChildren(element);

		let fragmentInfo = processFragmentExpression(attributeValue, context);
		if (fragmentInfo) {
			let templateName = fragmentInfo.templateName,
			    fragmentName = fragmentInfo.fragmentName;

			let template = resolveTemplate(templateName);

			let standardDialect = context.dialects.find(dialect => dialect.name === StandardDialect.NAME);
			let dialectPrefix = standardDialect.prefix;
			let fragmentProcessorName = StandardFragmentAttributeProcessor.NAME;
			let fragment = $(`[${dialectPrefix}\\:${fragmentProcessorName}^="${fragmentName}"]`, template) || $(`[data-${dialectPrefix}-${fragmentProcessorName}^="${fragmentName}"`, template);

			element.appendChild(fragment);
		}

		// TODO: Processors should be returning promises because this processor can
		//       have an asynchronous result.
		return true;
	}
}
StandardInsertAttributeProcessor.NAME = 'insert';

/*
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:src` attribute processor, applies the
 * expression in the attribute value to the `src` attribute of the element
 * being processed.
 * 
 * @author Emanuel Rabina
 */
class StandardSrcAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `src` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, StandardSrcAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:src` or `data-th-src` attribute
  * on it, taking the possible link expression in the value and applying it to
  * the `src` attribute of the element.
  * 
  * @param {Element} element 
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		element.src = encodeURI(processLinkExpression(attributeValue, context));
		element.removeAttribute(attribute);
	}
}
StandardSrcAttributeProcessor.NAME = 'src';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:text` attribute processor, applies the
 * expression in the attribute value to the text content of the element being
 * processed, escaping any unsafe input.
 * 
 * @author Emanuel Rabina
 */
class StandardTextAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `text` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, StandardTextAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:text` or `data-th-text` attribute
  * on it, taking the text expression in the value and applying it to the text
  * content of the element.
  * 
  * @param {Element} element 
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		element.textContent = processExpression(attributeValue, context);
		element.removeAttribute(attribute);
	}
}
StandardTextAttributeProcessor.NAME = 'text';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:utext` attribute processor, applies the
 * expression in the attribute value to the text content of the element being
 * processed.
 * 
 * @author Emanuel Rabina
 */
class StandardUTextAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `utext` name and supplied
  * prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, StandardUTextAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:utext` or `data-th-utext`
  * attribute on it, taking the text expression in the value and applying it to
  * the text content of the element.
  *
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		element.innerHTML = processExpression(attributeValue, context);
		element.removeAttribute(attribute);
	}
}
StandardUTextAttributeProcessor.NAME = 'utext';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The out-of-the-box dialect for Thymeleaf, the "Standard Dialect".
 * 
 * @author Emanuel Rabina
 */
class StandardDialect extends Dialect {

	/**
  * Create an instance of this dialect with the name "Standard" and
  * given prefix, defaulting to "th" if not supplied.
  * 
  * @param {String} [prefix='th']
  */
	constructor() {
		let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : StandardDialect.DEFAULT_PREFIX;


		super(StandardDialect.NAME, prefix);
	}

	/**
  * Returns the supported standard processors.
  * 
  * @return {Array} A list of the processors included in this dialect.
  */
	get processors() {

		// TODO: This is a very basic way of imposing the order of attribute
		//       processors.  It's currently ordered in the same way as OG
		//       Thymeleaf.  Figure out a 'proper' way to do the ordering.
		let prefix = this.prefix;

		return [new StandardInsertAttributeProcessor(prefix), new StandardEachAttributeProcessor(prefix), new StandardIfAttributeProcessor(prefix), new StandardAttrAttributeProcessor(prefix), new StandardHrefAttributeProcessor(prefix), new StandardSrcAttributeProcessor(prefix), new StandardTextAttributeProcessor(prefix), new StandardUTextAttributeProcessor(prefix), new StandardFragmentAttributeProcessor(prefix)];
	}
}
StandardDialect.NAME = 'Standard';
StandardDialect.DEFAULT_PREFIX = 'thjs';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const DEFAULT_CONFIGURATION = {
	dialects: [new StandardDialect()],
	isomorphic: false,
	templateResolver: {
		prefix: '',
		suffix: ''
	}
};

const STANDARD_CONFIGURATION = _extends({}, DEFAULT_CONFIGURATION, {
	dialects: [new StandardDialect('th')],
	isomorphic: {
		prefix: 'thjs'
	},
	templateResolver: {
		prefix: '',
		suffix: '.html'
	}
});

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Return the matching attribute of an element that a processor can work over.
 * 
 * @param {Element} element
 * @param {AttributeProcessor} processor
 * @param {Object} isomorphic
 * @return {String}
 *   The attribute that matched processing by this processor, or `null` if no
 *   match was found.
 */
function matchingAttributeProcessor(element, processor, isomorphic) {

  let prefixes = [].concat(isomorphic ? isomorphic.prefix : [], processor.prefix);
  let name = processor.name;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {

    for (var _iterator = prefixes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      let prefix = _step.value;

      let attribute;
      attribute = `${prefix}:${name}`;
      if (element.hasAttribute(attribute)) {
        return attribute;
      }
      attribute = `data-${prefix}-${name}`;
      if (element.hasAttribute(attribute)) {
        return attribute;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const XML_NAMESPACE_ATTRIBUTE = `xmlns:${StandardDialect.DEFAULT_PREFIX}`;

/**
 * A highly-configurable class responsible for processing the Thymeleaf
 * directives found in HTML documents and fragments.
 * 
 * @author Emanuel Rabina
 */
class TemplateEngine {

	/**
  * Constructor, set up a new template engine instance.
  * 
  * @param {Object} dialects
  *   List of dialects to use in the new template engine.  Defaults to just the
  *   standard dialect.
  * @param {Object} isomorphic
  *   Object for indicating whether this template engine is being used on
  *   templates meant for both ThymeleafJS and the original Thymeleaf.  If set,
  *   expects an object containing additional options for this special
  *   "isomorphic templating" mode.
  * @param {Object} templateResolver
  */
	constructor() {
		var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_CONFIGURATION;

		let dialects = _ref.dialects,
		    isomorphic = _ref.isomorphic,
		    templateResolver = _ref.templateResolver;


		this.dialects = dialects;
		this.isomorphic = isomorphic;
		this.processors = flatten(dialects.map(dialect => dialect.processors));
		this.templateResolver = templateResolver;
	}

	/**
  * Process a DOM element.
  * 
  * @private
  * @param {Element} element
  * @param {Object} [context={}]
  * @return {Boolean} Whether or not the parent node needs reprocessing.
  */
	processNode(element) {
		let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


		// TODO: Standardize this data attribute somewhere.  Shared const?
		// element.dataset not yet implemented in JSDOM (https://github.com/tmpvar/jsdom/issues/961),
		// so until then we're getting data- attributes the old-fashioned way.
		// Alternatively, some kind of variable stack that pops with each move up
		// the DOM.
		let localVariables = JSON.parse(element.getAttribute('data-thymeleaf-local-variables'));
		element.removeAttribute('data-thymeleaf-local-variables');
		let localContext = merge({}, context, localVariables);

		// Process the current element, store whether or not reprocessing of the
		// parent needs to happen before moving on to this element's children.
		let requireReprocessing = this.processors.map(processor => {
			// let attribute = processor.matches(element);
			let attribute = matchingAttributeProcessor(element, processor, this.isomorphic);
			return attribute ? processor.process(element, attribute, element.getAttribute(attribute), localContext) : false;
		}).reduce((accumulator, processorResult) => accumulator || processorResult, false);

		if (requireReprocessing) {
			return true;
		}

		// Process this element's children
		let reprocess;
		do {
			reprocess = false;
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = element.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					let child = _step.value;

					reprocess = this.processNode(child, localContext);
					if (reprocess) {
						break;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		} while (reprocess);
	}

	/**
  * Process the Thymeleaf template data, returning the processed template.
  * 
  * @param {String} template
  * @param {Object} [context={}]
  * @return {Promise}
  *   A promise resolved with the processed template, or rejected with an error
  *   message.
  */
	process(template) {
		let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


		return new Promise((resolve, reject) => {
			try {
				let document = deserialize(template);
				let rootElement = document.firstElementChild;
				this.processNode(rootElement, _extends({}, context, {
					dialects: this.dialects,
					templateResolver: this.templateResolver
				}));

				// TODO: Special case, remove the xmlns:th namespace from the document.
				//       This should be handled like in main Thymeleaf where it's just
				//       another processor that runs on the document.
				if (rootElement.hasAttribute(XML_NAMESPACE_ATTRIBUTE)) {
					rootElement.removeAttribute(XML_NAMESPACE_ATTRIBUTE);
				}

				let documentAsString = serialize(document);
				resolve(documentAsString);
			} catch (exception) {
				reject(exception);
			}
		});
	}

	/**
  * Process the Thymeleaf template at the given path, returning a promise of the
  * processed template.
  * 
  * @param {String} filePath
  * @param {Object} [context={}]
  * @return {Promise}
  *   A promise resolved with the processed template, or rejected with an error
  *   message.
  */
	processFile(filePath) {
		return Promise.reject('Cannot use fs.readFile inside a browser');
	}
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.STANDARD_CONFIGURATION = STANDARD_CONFIGURATION;
exports.TemplateEngine = TemplateEngine;
exports.Dialect = Dialect;
exports.AttributeProcessor = AttributeProcessor;
exports.StandardDialect = StandardDialect;
//# sourceMappingURL=thymeleaf.browser.cjs.js.map
